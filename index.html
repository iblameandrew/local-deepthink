<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Free Deep Think</title>
    <link rel="icon" type="image/svg+xml" href="/static/favicon.svg">

    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <link rel="stylesheet" href="css/prism-okaidia.min.css">
    <link rel="stylesheet" href="css/prism-toolbar.min.css">
    <link rel="stylesheet" href="css/node-chat.css">
    <style>
        :root {
            --primary-color: #0E1117;
            --secondary-color: #262730;
            --accent-color: #FF4B4B;
            --text-color: #FAFAFA;
            --font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
            --border-radius: 0.5rem;
        }

        body {
            background-color: var(--primary-color);
            color: var(--text-color);
            font-family: var(--font-family);
            margin: 0;
            padding: 2rem;
            font-size: 16px;
            line-height: 1.6;
        }

        h1,
        h2 {
            color: var(--text-color);
            border-bottom: 1px solid var(--secondary-color);
            padding-bottom: 0.5rem;
            margin-top: 2rem;
            margin-bottom: 1rem;
        }

        h1 {
            text-align: center;
            font-size: 2.5rem;
            border-bottom: none;
        }

        h2 {
            font-size: 1.75rem;
        }

        .container {
            width: 100%;
            max-width: 800px;
            margin: 0 auto;
            background-color: var(--primary-color);
            padding: 2rem;
            border-radius: var(--border-radius);
            margin-bottom: 2rem;
        }

        .section {
            background-color: var(--secondary-color);
            padding: 2rem;
            border-radius: var(--border-radius);
            margin-bottom: 2rem;
        }

        .hidden {
            display: none;
        }

        label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 500;
        }

        input,
        textarea,
        button,
        select {
            width: 100%;
            padding: 0.75rem;
            margin-bottom: 1rem;
            border: 1px solid var(--secondary-color);
            background-color: #1C1E25;
            color: var(--text-color);
            border-radius: var(--border-radius);
            box-sizing: border-box;
            font-family: inherit;
            font-size: 1rem;
        }

        input:focus,
        textarea:focus,
        select:focus {
            outline: none;
            border-color: var(--accent-color);
            box-shadow: 0 0 0 2px rgba(255, 75, 75, 0.3);
        }

        textarea {
            min-height: 120px;
            resize: vertical;
        }

        button {
            cursor: pointer;
            background-color: var(--accent-color);
            color: var(--text-color);
            font-weight: bold;
            border: none;
            transition: background-color 0.3s ease;
        }

        button:hover:not(:disabled) {
            background-color: #E03C3C;
        }

        button:disabled {
            background-color: #555;
            cursor: not-allowed;
        }

        #log-container {
            height: 400px;
            background-color: #000;
            border: 1px solid var(--secondary-color);
            border-radius: var(--border-radius);
            padding: 1rem;
            overflow-y: scroll;
            font-family: 'Menlo', 'Consolas', 'Courier New', monospace;
            font-size: 0.9em;
            color: #C0C0C0;
            white-space: pre-wrap;
        }

        #graph-container {
            min-height: 400px;
            background-color: #000;
            border: 1px solid var(--secondary-color);
            border-radius: var(--border-radius);
            padding: 1rem;
            overflow-x: auto;
            font-family: 'Menlo', 'Consolas', 'Courier New', monospace;
            font-size: 0.9em;
            color: #C0C0C0;
            white-space: pre;
        }

        #graph-container p {
            color: #888;
            white-space: pre-wrap;
        }

        .mbti-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
            gap: 1rem;
            background-color: #1C1E25;
            padding: 1rem;
            border-radius: var(--border-radius);
            margin-bottom: 1rem;
        }

        .mbti-option {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .mbti-option input[type="checkbox"] {
            width: auto;
            margin-bottom: 0;
        }

        .mbti-option label {
            margin-bottom: 0;
            font-weight: normal;
        }

        #results-container pre,
        #hidden-outputs-container pre,
        #papers-container pre,
        #code-result-container pre,
        #modules-container pre {
            background-color: #000;
            padding: 1rem;
            border-radius: var(--border-radius);
            white-space: pre-wrap;
            word-wrap: break-word;
            color: #FAFAFA;
        }

        .header-with-button {
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid var(--secondary-color);
            padding-bottom: 0.5rem;
            margin-bottom: 1rem;
        }

        .header-with-button h2,
        .header-with-button h3 {
            border-bottom: none;
            padding-bottom: 0;
            margin: 0;
        }

        #download-log-button,
        .download-paper-button,
        #export-qnn-button {
            width: auto;
            padding: 0.5rem 1rem;
            margin-bottom: 0;
            font-size: 0.9rem;
            background-color: var(--secondary-color);
        }

        #download-log-button:hover:not(:disabled),
        .download-paper-button:hover:not(:disabled),
        #export-qnn-button:hover:not(:disabled) {
            background-color: #3a3b44;
        }

        .chat-messages {
            height: 400px;
            background-color: #000;
            border: 1px solid var(--secondary-color);
            border-radius: var(--border-radius);
            padding: 1rem;
            margin-bottom: 1rem;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .chat-message {
            padding: 0.75rem 1rem;
            border-radius: var(--border-radius);
            max-width: 80%;
            line-height: 1.5;
            word-wrap: break-word;
        }

        .user-message {
            background-color: var(--accent-color);
            color: var(--text-color);
            align-self: flex-end;
            border-bottom-right-radius: 0;
        }

        .ai-message {
            background-color: var(--secondary-color);
            color: var(--text-color);
            align-self: flex-start;
            border-bottom-left-radius: 0;
            white-space: pre-wrap;
        }

        #diagnostic-chat-form {
            display: flex;
            gap: 1rem;
        }

        #diagnostic-chat-input {
            flex-grow: 1;
            min-height: 50px;
            height: 50px;
            margin-bottom: 0;
            resize: none;
        }

        #diagnostic-chat-send-button {
            width: auto;
            margin-bottom: 0;
            align-self: flex-end;
        }



        #diagnostic-chat-container {
            border: 2px solid #007bff;
        }

        #diagnostic-chat-container h2 {
            color: #00aaff;
            border-bottom-color: #007bff;
        }

        .diagnostic-ai-message {
            background-color: #1c2e4a;
            color: #e0e0ff;
            align-self: flex-start;
            border-bottom-left-radius: 0;
            white-space: pre-wrap;
        }

        .diagnostic-user-message {
            background-color: #0056b3;
            color: var(--text-color);
            align-self: flex-end;
            border-bottom-right-radius: 0;
        }

        .qnn-import-section {
            border: 2px dashed var(--accent-color);
            padding: 1.5rem;
            margin-bottom: 2rem;
            text-align: center;
        }

        .qnn-import-section label {
            cursor: pointer;
            background-color: var(--secondary-color);
            padding: 0.75rem 1.5rem;
            border-radius: var(--border-radius);
            display: inline-block;
            margin-bottom: 1rem;
        }

        .qnn-import-section input[type="file"] {
            display: none;
        }

        #imported-qnn-info {
            background-color: #1c2e4a;
            padding: 1rem;
            border-radius: var(--border-radius);
            margin-top: 1rem;
            text-align: left;
        }

        #inference-options {
            display: flex;
            gap: 1rem;
            justify-content: center;
            margin-top: 1rem;
        }

        #inference-options button {
            background-color: #007bff;
            width: 50%;
        }

        #inference-options button:hover:not(:disabled) {
            background-color: #0056b3;
        }

        /* Mode Tabs */
        .mode-tabs {
            display: flex;
            gap: 0;
            margin-bottom: 1.5rem;
            border-bottom: 2px solid var(--secondary-color);
        }

        .mode-tab {
            padding: 1rem 2rem;
            background: transparent;
            border: none;
            color: #888;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 600;
            transition: all 0.3s ease;
            border-bottom: 2px solid transparent;
            margin-bottom: -2px;
        }

        .mode-tab:hover {
            color: var(--text-color);
            background: rgba(255, 255, 255, 0.05);
        }

        .mode-tab.active {
            color: var(--accent-color);
            border-bottom-color: var(--accent-color);
        }

        /* Settings Panel */
        .settings-panel {
            background: linear-gradient(145deg, #1a1d24, #22252e);
            border: 1px solid var(--secondary-color);
            padding: 1rem 1.5rem;
            border-radius: var(--border-radius);
            margin-bottom: 1.5rem;
            display: flex;
            align-items: center;
            gap: 1rem;
            flex-wrap: wrap;
        }

        .settings-panel label {
            margin: 0;
            font-weight: 600;
            color: #aaa;
        }

        .settings-panel input {
            flex: 1;
            min-width: 200px;
            margin: 0;
        }

        .settings-panel button {
            width: auto;
            padding: 0.5rem 1.5rem;
            margin: 0;
        }

        .api-key-status {
            color: #28a745;
            font-size: 0.9rem;
        }

        /* Brainstorming Mode */
        /* Mode Containers */
        /* .container display: block; REMOVED to avoid conflicts */

        .brainstorm-container,
        .algorithm-container,
        .distillation-container {
            display: none;
        }

        .brainstorm-container.active,
        .algorithm-container.active,
        .distillation-container.active {
            display: block;
        }

        /* Utility class to force hide */
        .hidden {
            display: none !important;
        }

        .expert-panel {
            background: linear-gradient(145deg, #1c2030, #252a38);
            border-radius: var(--border-radius);
            padding: 1rem;
            margin-bottom: 1rem;
        }

        .expert-panel h3 {
            margin: 0 0 0.75rem 0;
            color: var(--accent-color);
            border-bottom: none;
        }

        .expert-list {
            display: flex;
            flex-wrap: wrap;
            gap: 0.75rem;
        }

        .expert-badge {
            background: rgba(255, 255, 255, 0.08);
            padding: 0.5rem 1rem;
            border-radius: 2rem;
            font-size: 0.85rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .expert-badge .specialty {
            color: #888;
            font-size: 0.75rem;
        }

        .brainstorm-chat {
            background: #000;
            border: 1px solid var(--secondary-color);
            border-radius: var(--border-radius);
            height: 450px;
            overflow-y: auto;
            padding: 1rem;
            margin-bottom: 1rem;
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .expert-message {
            background: linear-gradient(145deg, #1a2940, #1e3355);
            border-radius: var(--border-radius);
            padding: 1rem;
            border-left: 3px solid #007bff;
        }

        .expert-message-header {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 0.5rem;
            font-weight: 600;
        }

        .expert-message-header .specialty {
            color: #888;
            font-weight: normal;
            font-size: 0.85rem;
        }

        .synthesis-message {
            background: linear-gradient(145deg, #2d3a2d, #354535);
            border-radius: var(--border-radius);
            padding: 1rem;
            border-left: 3px solid #28a745;
        }

        .synthesis-message-header {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 0.5rem;
            font-weight: 600;
            color: #28a745;
        }

        .thinking-indicator {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            color: #888;
            font-style: italic;
        }

        .thinking-dots {
            display: inline-flex;
            gap: 2px;
        }

        .thinking-dots span {
            width: 6px;
            height: 6px;
            background: var(--accent-color);
            border-radius: 50%;
            animation: thinking 1.4s ease-in-out infinite;
        }

        .thinking-dots span:nth-child(2) {
            animation-delay: 0.2s;
        }

        .thinking-dots span:nth-child(3) {
            animation-delay: 0.4s;
        }

        @keyframes thinking {

            0%,
            80%,
            100% {
                opacity: 0.3;
                transform: scale(0.8);
            }

            40% {
                opacity: 1;
                transform: scale(1);
            }
        }

        .brainstorm-input-form {
            display: flex;
            gap: 1rem;
        }

        .brainstorm-input-form textarea {
            flex: 1;
            min-height: 60px;
            margin: 0;
            resize: none;
        }

        .brainstorm-input-form button {
            width: auto;
            align-self: flex-end;
        }
    </style>
</head>

<body>
    <h1>It takes a village of agents to raise an agent</h1>

    <!-- Settings Panel -->
    <div class="container">
        <div class="settings-panel" style="flex-wrap: wrap;">
            <label for="llm-provider">ü§ñ LLM Provider:</label>
            <select id="llm-provider"
                style="padding: 0.5rem; border-radius: 4px; background: #1a1d24; color: #fff; border: 1px solid #333;">
                <option value="gemini">Gemini (Cloud)</option>
                <option value="grok">Grok (xAI)</option>
                <option value="openrouter">OpenRouter</option>
                <option value="llamacpp">LlamaCpp Server</option>

            </select>

            <div id="gemini-config" style="display: flex; gap: 0.5rem; align-items: center;">
                <label for="gemini-api-key">üîë API Key:</label>
                <input type="password" id="gemini-api-key" placeholder="Gemini API key..." style="min-width: 180px;">
            </div>

            <div id="grok-config" style="display: none; gap: 0.5rem; align-items: center;">
                <label for="grok-api-key">üåå API Key:</label>
                <input type="password" id="grok-api-key" placeholder="Grok API key..." style="min-width: 180px;">
                <label for="grok-openrouter-key">üîó OR Key (Embeddings):</label>
                <input type="password" id="grok-openrouter-key" placeholder="OpenRouter Key..."
                    style="min-width: 180px;">
            </div>

            <div id="openrouter-config" style="display: none; gap: 0.5rem; align-items: center;">
                <label for="openrouter-api-key">üîó API Key:</label>
                <input type="password" id="openrouter-api-key" placeholder="OpenRouter API key..."
                    style="min-width: 180px;">
                <label for="openrouter-model">üì¶ Model:</label>
                <input type="text" id="openrouter-model" value="stepfun/step-3.5-flash:free" placeholder="model-name"
                    style="min-width: 200px;">
            </div>

            <div id="llamacpp-config" style="display: none; gap: 0.5rem; align-items: center;">
                <label for="llamacpp-url">üîó Server URL:</label>
                <input type="text" id="llamacpp-url" value="http://localhost:8080/v1/chat/completions"
                    placeholder="http://localhost:8080/v1/chat/completions" style="min-width: 320px;">
                <label for="llamacpp-embedding-url">üß† Embedding URL:</label>
                <input type="text" id="llamacpp-embedding-url" value="http://localhost:8080/v1"
                    placeholder="http://localhost:8080/v1" style="min-width: 320px;">
            </div>



            <button type="button" id="save-api-key-btn">Save</button>
            <span id="api-key-status" class="api-key-status"></span>
        </div>
    </div>

    <!-- Mode Tabs -->
    <div class="container">
        <div class="mode-tabs">
            <button class="mode-tab active" data-mode="algorithm">üß¨ Algorithm Design Mode</button>
            <button class="mode-tab" data-mode="brainstorm">üß† Brainstorming Mode</button>
            <button class="mode-tab" data-mode="distillation">‚öóÔ∏è Knowledge Distillation</button>
        </div>
    </div>


    <!-- Knowledge Distillation Mode Container -->
    <div class="container distillation-container hidden" id="distillation-mode">
        <div class="section">
            <h2 style="color: #0f0; border-bottom-color: #0f0;">‚öóÔ∏è Knowledge Distillation Graph</h2>
            <form id="distillation-form">
                <label for="distil-topics">Topics (comma separated):</label>
                <input type="text" id="distil-topics"
                    placeholder="e.g. Artificial Intelligence, Neuroscience, Philosophy" required>

                <div id="anchors-container">
                    <div class="anchor-item section"
                        style="background: rgba(255,255,255,0.05); padding: 1rem; margin-bottom: 1rem; border: 1px solid #444;">
                        <div
                            style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem;">
                            <h4 style="margin: 0; color: #0f0;">‚öì Anchor 1</h4>
                        </div>
                        <label>Anchor Question:</label>
                        <textarea class="distil-anchor" placeholder="Enter the grand objective or anchor question..."
                            style="min-height: 80px;" required></textarea>

                        <label>Token Budget:</label>
                        <input type="number" class="distil-budget" value="1000000" step="10000">
                    </div>
                </div>

                <button type="button" id="add-anchor-btn"
                    style="background-color: #444; margin-bottom: 1.5rem; width: auto; padding: 0.5rem 1rem;">+ Add
                    Another Anchor</button>

                <div style="display: flex; align-items: center; gap: 8px; margin: 10px 0;">
                    <input type="checkbox" id="distil-debug-mode">
                    <label for="distil-debug-mode" style="color: #aaa; cursor: pointer; font-size: 0.9rem;">
                        üöÄ Debug Mode (Mock Data & Fast Epochs)
                    </label>
                </div>

                <div style="display: flex; gap: 8px; flex-wrap: wrap;">
                    <button type="submit" id="start-distillation-btn" style="background-color: #28a745;">Start
                        Distillation</button>
                    <button type="button" id="stop-distillation-btn" style="background-color: #dc3545; display: none;"
                        onclick="stopDistillation()">‚èπ Stop</button>
                    <button type="button" id="download-distillation-btn"
                        style="background-color: #007bff; display: none;"
                        onclick="window.open('/download_distillation','_blank')">‚¨á Download Dataset</button>
                </div>
            </form>

            <!-- Token Counter Bar -->
            <div id="distil-token-bar" style="margin-top: 10px; display: none;">
                <div
                    style="display: flex; justify-content: space-between; font-size: 0.8rem; color: #aaa; margin-bottom: 4px;">
                    <span id="distil-token-info">0 / 1,000,000 tokens</span>
                    <span id="distil-epoch-info">Epoch: 0</span>
                    <span id="distil-qa-info">QA Pairs: 0</span>
                </div>
                <div style="width: 100%; background: #333; border-radius: 4px; height: 8px;">
                    <div id="distil-progress"
                        style="width: 0%; background: linear-gradient(90deg, #0f0, #0a0); height: 100%; border-radius: 4px; transition: width 0.3s;">
                    </div>
                </div>
            </div>
        </div>

        <div class="section">
            <h3>Topology & Metrics</h3>
            <div style="display: flex; gap: 1rem; flex-wrap: wrap;">
                <div style="flex: 1; min-width: 300px;">
                    <h4 style="margin-top:0;">ASCII Topology (1√ó2√ó2√ó2√ó2√ó2√ó1)</h4>
                    <div id="distil-topology"
                        style="min-height: 300px; background: #000; padding: 10px; font-family: monospace; white-space: pre; font-size: 0.75rem; overflow: auto; border: 1px solid #333; color: #00ff00; line-height: 1.4;">
                        Waiting for data...</div>
                </div>
                <div style="flex: 1; min-width: 300px;">
                    <h4 style="margin-top:0;">Distillation Console</h4>
                    <div id="distil-console"
                        style="min-height: 300px; max-height: 400px; background: #0a0a0a; padding: 10px; font-family: monospace; font-size: 0.75rem; overflow-y: auto; border: 1px solid #333; color: #0f0;">
                        Waiting for distillation to start...</div>
                </div>
            </div>
        </div>
    </div>

    <!-- Brainstorming Mode Container -->
    <div class="container brainstorm-container hidden" id="brainstorm-mode">
        <!-- ... existing brainstorm content ... -->
        <div class="section">
            <div style="margin-bottom: 10px; display: flex; align-items: center; gap: 15px; flex-wrap: wrap;">
                <div style="display: flex; align-items: center; gap: 5px;">
                    <label for="brainstorm_epochs" style="color: #aaa; font-size: 0.9rem;">Epochs:</label>
                    <input type="number" id="brainstorm_epochs" value="2" min="1" max="10"
                        style="width: 50px; padding: 4px; border-radius: 4px; border: 1px solid #444; background: #222; color: #eee;">
                </div>
                <div style="display: flex; align-items: center; gap: 8px;">
                    <input type="checkbox" id="brainstorm_debug_mode">
                    <label for="brainstorm_debug_mode" style="color: #aaa; cursor: pointer; font-size: 0.9rem;">üöÄ
                        Simulation Mode (Mock LLM - No Cost)</label>
                </div>
            </div>

            <!-- PDF Upload Section -->
            <div id="pdf-upload-section"
                style="margin-bottom: 15px; padding: 1rem; background: #1a1d24; border-radius: 8px; border: 1px dashed #444;">
                <div style="display: flex; align-items: center; gap: 10px; flex-wrap: wrap;">
                    <label for="pdf-file-input"
                        style="cursor: pointer; background: #262730; padding: 8px 16px; border-radius: 6px; display: flex; align-items: center; gap: 6px; font-size: 0.9rem;">
                        üìÑ Attach PDFs
                    </label>
                    <input type="file" id="pdf-file-input" accept=".pdf" multiple style="display: none;">
                    <span id="pdf-upload-status" style="color: #888; font-size: 0.85rem;"></span>
                    <button type="button" id="clear-pdfs-btn"
                        style="display: none; background: #444; padding: 6px 12px; border-radius: 4px; font-size: 0.8rem; width: auto;">Clear
                        All</button>
                </div>
                <div id="attached-documents-list" style="margin-top: 10px; display: none;">
                    <div style="font-size: 0.85rem; color: #888; margin-bottom: 6px;">Attached Documents:</div>
                    <div id="documents-list" style="display: flex; flex-wrap: wrap; gap: 8px;"></div>
                </div>
            </div>

            <!-- NodeChat Mount Point -->
            <div id="node-chat-container" style="height: 550px;"></div>
        </div>
    </div>



    <!-- Algorithm Design Mode Container -->
    <div class="algorithm-container hidden" id="algorithm-mode">
        <div class="container">
            <div id="qnn-import-container" class="section qnn-import-section">
                <h2>Load a Pre-Trained QNN</h2>
                <p>Import a previously exported QNN JSON file to continue training or run in inference-only
                    mode.</p>
                <form id="import-qnn-form">
                    <label for="qnn-file-input">Select QNN File</label>
                    <input type="file" id="qnn-file-input" accept=".json">
                </form>
                <div id="imported-qnn-info" class="hidden">
                    <p><strong>File Loaded:</strong> <span id="loaded-filename"></span></p>
                    <p>A QNN file has been loaded. You can modify the prompt below. Then, choose an execution
                        mode:</p>
                    <div id="inference-options">
                        <button id="inference-continue-training-btn" hidden>Continue Training</button>
                        <button id="inference-only-btn">Run Inference Only</button>
                    </div>
                </div>
            </div>

            <div id="graph-architecture" class="section">
                <h2>Graph Architecture</h2>
                <form id="graph-params-form">
                    <div id="debug-options" style="display: flex; gap: 2rem; margin-bottom: 1rem; margin-top: 0.5rem;">
                        <div class="mbti-option">
                            <input type="checkbox" id="coder_debug_mode" name="coder_debug_mode" value="true">
                            <label for="coder_debug_mode">üíª Enable Coder Debug (Code)</label>
                        </div>
                    </div>

                    <label for="cot_trace_depth">CoT trace depth (max 32):</label>
                    <input type="number" id="cot_trace_depth" name="cot_trace_depth" value="2" max="32" min="2"
                        required>

                    <label for="num_epochs">Number of epochs:</label>
                    <input type="number" id="num_epochs" name="num_epochs" value="1" required>
                    <label for="vector_word_size">Vector word size (Number of verbs per agent):</label>
                    <input type="number" id="vector_word_size" name="vector_word_size" value="2" min="2" max="20"
                        required>
                    <label for="prompt_alignment">Prompt alignment (0.1-2.0):</label>
                    <input type="number" id="prompt_alignment" name="prompt_alignment" step="0.1" min="0.1" max="2.0"
                        value="1.0" required>
                    <label for="density">Density (0.1-2.0):</label>
                    <input type="number" id="density" name="density" step="0.1" min="0.1" max="2.0" value="1.0"
                        required>
                    <label for="learning_rate">Learning rate (0.1-2.0):</label>
                    <input type="number" id="learning_rate" name="learning_rate" step="0.1" min="0.1" max="2.0"
                        value="0.1" required>
                    <label>MBTI Archetypes (select at least 2):</label>
                    <div class="mbti-grid">
                        <div class="mbti-option"><input type="checkbox" id="mbti-istj" name="mbti_archetypes"
                                value="ISTJ" checked><label for="mbti-istj">ISTJ (Inspector)</label></div>
                        <div class="mbti-option"><input type="checkbox" id="mbti-isfj" name="mbti_archetypes"
                                value="ISFJ" checked><label for="mbti-isfj">ISFJ (Protector)</label></div>
                        <div class="mbti-option"><input type="checkbox" id="mbti-infj" name="mbti_archetypes"
                                value="INFJ"><label for="mbti-infj">INFJ (Advocate)</label></div>
                        <div class="mbti-option"><input type="checkbox" id="mbti-intj" name="mbti_archetypes"
                                value="INTJ"><label for="mbti-intj">INTJ (Architect)</label></div>
                        <div class="mbti-option"><input type="checkbox" id="mbti-istp" name="mbti_archetypes"
                                value="ISTP"><label for="mbti-istp">ISTP (Virtuoso)</label></div>
                        <div class="mbti-option"><input type="checkbox" id="mbti-isfp" name="mbti_archetypes"
                                value="ISFP"><label for="mbti-isfp">ISFP (Adventurer)</label></div>
                        <div class="mbti-option"><input type="checkbox" id="mbti-infp" name="mbti_archetypes"
                                value="INFP"><label for="mbti-infp">INFP (Mediator)</label></div>
                        <div class="mbti-option"><input type="checkbox" id="mbti-intp" name="mbti_archetypes"
                                value="INTP"><label for="mbti-intp">INTP (Logician)</label></div>
                        <div class="mbti-option"><input type="checkbox" id="mbti-estp" name="mbti_archetypes"
                                value="ESTP"><label for="mbti-estp">ESTP (Entrepreneur)</label></div>
                        <div class="mbti-option"><input type="checkbox" id="mbti-esfp" name="mbti_archetypes"
                                value="ESFP"><label for="mbti-esfp">ESFP (Entertainer)</label></div>
                        <div class="mbti-option"><input type="checkbox" id="mbti-enfp" name="mbti_archetypes"
                                value="ENFP"><label for="mbti-enfp">ENFP (Campaigner)</label></div>
                        <div class="mbti-option"><input type="checkbox" id="mbti-entp" name="mbti_archetypes"
                                value="ENTP"><label for="mbti-entp">ENTP (Debater)</label></div>
                        <div class="mbti-option"><input type="checkbox" id="mbti-estj" name="mbti_archetypes"
                                value="ESTJ"><label for="mbti-estj">ESTJ (Executive)</label></div>
                        <div class="mbti-option"><input type="checkbox" id="mbti-esfj" name="mbti_archetypes"
                                value="ESFJ"><label for="mbti-esfj">ESFJ (Consul)</label></div>
                        <div class="mbti-option"><input type="checkbox" id="mbti-enfj" name="mbti_archetypes"
                                value="ENFJ"><label for="mbti-enfj">ENFJ (Protagonist)</label></div>
                        <div class="mbti-option"><input type="checkbox" id="mbti-entj" name="mbti_archetypes"
                                value="ENTJ"><label for="mbti-entj">ENTJ (Commander)</label></div>
                    </div>
                    <label for="prompt">Prompt:</label>
                    <textarea id="prompt" name="prompt" required>


                    Current diffusers and transformer architectures use integral samplers or differential solvers in the case of diffusers, and decoding algorithms which account as integral, in the case of transformers, to run inference. I presume the foundation of training and architecture are allready figured out, so i want you to create a new inference algorithm that helps exsiting architectures acheive AGI. For this conceptualziation assume the world is full of spinning wheels (harmonic oscillators), like we see them in atoms, solar systems, galaxies, human hierarchies...etc, and data represents a measured state of the "wheel" at a given time. Abudant training data samples the full state of the "wheel" by offering all the posible data of the wheel full state. This is where understanding is reached: by spinning the whole wheel and assimilating all possible perspectives. Current inference algoritms on the other hand, are not fully decoding the internal "implicit wheels" abstracted into the weights after training, as their responses can be shallow. The training algorithms encode the wheels but inference algorithms do not extract them very well. I want you to make in python with excellent documentation: 1. An inference algorithm to achieve AGI through better inference using a PID like approach with perturbative feedback. Instead of just using either an integrative or differential component, i want you to implement both with proportional weighting terms. Figure out a good way to integrate PID loops into transformer inference so transformers learn on inference. 2. a gradio app to monitor the algorithm during an inference run on a mocked transformer which should be built to be sufficiently dense to provide realistic output/input.


                </textarea>
                    <button type="submit" id="run-button">Build and Run Graph</button>
                </form>
            </div>
        </div>

        <div class="container" id="diagnostic-chat-wrapper">
            <div id="diagnostic-node-chat-container" style="height: 600px;"></div>
        </div>





        <div class="container hidden" id="code-result-container">
            <h2>Generated Code</h2>
            <p>The graph execution is complete. The following code has been generated based on your request.</p>
            <pre><code id="code-output" class="language-python"></code></pre>
            <h3>Reasoning:</h3>
            <p id="code-reasoning" style="white-space: pre-wrap;"></p>
        </div>

        <div class="container hidden" id="modules-container">
            <h2>Successfully Built Modules</h2>
            <p>The following modules were successfully synthesized and executed during the run.</p>
            <div id="modules-output"></div>
        </div>

        <button id="export-qnn-button" class="hidden">Export QNN</button>
    </div>
    </div>
    <!-- End Algorithm Design Mode Container -->

    <!-- Shared Visualization Containers -->
    <div class="container" id="perplexity-chart-container">
        <h2>Average Perplexity per Epoch</h2>
        <canvas id="perplexityChart"></canvas>
    </div>

    <div class="container" id="log-wrapper">
        <div class="header-with-button">
            <h2>Real-time Graph Activity</h2>
            <div id="token-display"
                style="background: rgba(0,0,0,0.3); padding: 5px 10px; border-radius: 4px; font-family: monospace; font-size: 0.9rem; color: #aaa; border: 1px solid #333; display: flex; gap: 10px;">
                <span>Total: <b id="tokens-total" style="color: #fff;">0</b></span>
                <span style="font-size: 0.8em; color: #777;">(In: <span id="tokens-prompt">0</span> Out: <span
                        id="tokens-completion">0</span>)</span>
            </div>
            <button id="download-log-button" disabled>Download Full Log</button>
        </div>
        <div id="log-container"></div>
    </div>

    <div class="container" id="graph-wrapper">
        <h2>Graph Visualization</h2>
        <div id="graph-container">
            <p>ASCII graph will be displayed here after the process starts...</p>
        </div>
    </div>

    <script src="js/chart.js"></script>
    <script src="js/components/node-chat.js"></script>
    <script>
        const graphParamsForm = document.getElementById('graph-params-form');
        const runButton = document.getElementById('run-button');
        const logContainer = document.getElementById('log-container');
        const graphContainer = document.getElementById('graph-container');
        const coderDebugModeCheckbox = document.getElementById('coder_debug_mode');
        const downloadLogButton = document.getElementById('download-log-button');
        const perplexityChartContainer = document.getElementById('perplexity-chart-container');
        const perplexityChartCanvas = document.getElementById('perplexityChart').getContext('2d');
        const graphArchitectureSection = document.getElementById('graph-architecture');

        const diagnosticChatWrapper = document.getElementById('diagnostic-chat-wrapper');
        let diagnosticChatInstance = null;

        const codeResultContainer = document.getElementById('code-result-container');
        const codeOutput = document.getElementById('code-output');
        const codeReasoning = document.getElementById('code-reasoning');

        const modulesContainer = document.getElementById('modules-container');
        const modulesOutput = document.getElementById('modules-output');

        const qnnImportContainer = document.getElementById('qnn-import-container');
        const qnnFileInput = document.getElementById('qnn-file-input');
        const importedQnnInfo = document.getElementById('imported-qnn-info');
        const loadedFilename = document.getElementById('loaded-filename');
        const inferenceContinueTrainingBtn = document.getElementById('inference-continue-training-btn');
        const inferenceOnlyBtn = document.getElementById('inference-only-btn');
        const exportQnnButton = document.getElementById('export-qnn-button');

        let fullLogContent = '';

        let perplexityChart = null;
        let allPerplexityValues = [];
        let allLbelsData = [];
        let currentSessionId = null;

        const addLogMessage = (text, options = {}) => {
            fullLogContent += text + '\n';
            if (downloadLogButton.disabled) {
                downloadLogButton.disabled = false;
            }
            const container = document.createElement('div');
            container.style.margin = '0';
            container.style.lineHeight = '1.4';

            if (options.isHTML) {
                container.innerHTML = text;
            } else {
                container.textContent = text;
            }

            if (options.color) container.style.color = options.color;

            logContainer.appendChild(container);
            logContainer.scrollTop = logContainer.scrollHeight;
        };

        const downloadLog = () => {
            const blob = new Blob([fullLogContent], { type: 'text/plain;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
            a.download = `noa-run-log-${timestamp}.txt`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        };

        const renderPerplexityChart = () => {
            if (perplexityChart) {
                perplexityChart.destroy();
            }
            const labels = allLbelsData;
            const data = allPerplexityValues;

            perplexityChart = new Chart(perplexityChartCanvas, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Average Agent Perplexity',
                        data: data,
                        borderColor: 'rgba(255, 75, 75, 1)',
                        backgroundColor: 'rgba(255, 75, 75, 0.2)',
                        fill: true,
                        tension: 0.1
                    }]
                },
                options: {
                    responsive: true,
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: { display: true, text: 'Perplexity Score' }
                        },
                        x: {
                            title: { display: true, text: 'Epoch' }
                        }
                    }
                }
            });
        };

        const updatePerplexityChart = (epoch, perplexity) => {
            allLbelsData.push(epoch);
            allPerplexityValues.push(perplexity);
            renderPerplexityChart();
        };

        // --- Distillation Mode Variables ---
        const distillationContainer = document.getElementById('distillation-mode');
        const distillationForm = document.getElementById('distillation-form');
        const distilTopologyContainer = document.getElementById('distil-topology');

        const startDistillationBtn = document.getElementById('start-distillation-btn');

        // --- Mode Switching Logic ---
        document.querySelectorAll('.mode-tab').forEach(tab => {
            tab.addEventListener('click', () => {
                document.querySelectorAll('.mode-tab').forEach(t => t.classList.remove('active'));
                tab.classList.add('active');

                // Re-fetch elements to be safe
                const bs = document.getElementById('brainstorm-mode');
                const algo = document.getElementById('algorithm-mode');
                const distil = document.getElementById('distillation-mode');

                const mode = tab.dataset.mode;

                if (bs) {
                    bs.classList.add('hidden');
                    bs.classList.remove('active');
                }
                if (algo) algo.classList.add('hidden');
                if (distil) distil.classList.add('hidden');

                // Update Containers
                [bs, algo, distil].forEach(c => {
                    if (c) {
                        c.classList.add('hidden');
                        c.classList.remove('active');
                    }
                });

                if (mode === 'brainstorm') {
                    if (bs) {
                        bs.classList.remove('hidden');
                        bs.classList.add('active');
                    }
                } else if (mode === 'algorithm') {
                    if (algo) {
                        algo.classList.remove('hidden');
                        algo.classList.add('active');
                    }
                } else if (mode === 'distillation') {
                    if (distil) {
                        distil.classList.remove('hidden');
                        distil.classList.add('active');
                    }
                }

                const globalPerplexity = document.getElementById('perplexity-chart-container');
                const globalLogComp = document.getElementById('log-wrapper');
                const globalGraphComp = document.getElementById('graph-wrapper');

                if (mode === 'brainstorm') {
                    if (globalPerplexity) globalPerplexity.classList.remove('hidden');
                    if (globalLogComp) globalLogComp.classList.remove('hidden');
                    if (globalGraphComp) globalGraphComp.classList.remove('hidden');
                } else if (mode === 'algorithm') {
                    if (globalPerplexity) globalPerplexity.classList.remove('hidden');
                    if (globalLogComp) globalLogComp.classList.remove('hidden');
                    if (globalGraphComp) globalGraphComp.classList.remove('hidden');
                } else if (mode === 'distillation') {
                    if (globalPerplexity) globalPerplexity.classList.remove('hidden');
                    if (globalLogComp) globalLogComp.classList.remove('hidden');
                    if (globalGraphComp) globalGraphComp.classList.add('hidden');
                }
            });

            // Trigger click on active tab to set initial state
            if (tab.classList.contains('active')) {
                // Wait for DOM slightly to be safe
                setTimeout(() => tab.click(), 0);
            }
        });

        // --- Distillation Form Logic ---
        const anchorsContainer = document.getElementById('anchors-container');
        const addAnchorBtn = document.getElementById('add-anchor-btn');

        if (addAnchorBtn) {
            addAnchorBtn.addEventListener('click', () => {
                const anchorCount = anchorsContainer.querySelectorAll('.anchor-item').length + 1;
                const anchorItem = document.createElement('div');
                anchorItem.className = 'anchor-item section';
                anchorItem.style.cssText = 'background: rgba(255,255,255,0.05); padding: 1rem; margin-bottom: 1rem; border: 1px solid #444;';
                anchorItem.innerHTML = `
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem;">
                        <h4 style="margin: 0; color: #0f0;">‚öì Anchor ${anchorCount}</h4>
                        <button type="button" class="remove-anchor-btn" style="width: auto; padding: 2px 8px; background: #dc3545; margin: 0;">&times;</button>
                    </div>
                    <label>Anchor Question:</label>
                    <textarea class="distil-anchor" placeholder="Enter the grand objective or anchor question..."
                        style="min-height: 80px;" required></textarea>

                    <label>Token Budget:</label>
                    <input type="number" class="distil-budget" value="1000000" step="10000">
                `;
                anchorsContainer.appendChild(anchorItem);

                anchorItem.querySelector('.remove-anchor-btn').addEventListener('click', () => {
                    anchorItem.remove();
                    // Renumber remaining anchors
                    anchorsContainer.querySelectorAll('.anchor-item').forEach((item, idx) => {
                        item.querySelector('h4').textContent = `‚öì Anchor ${idx + 1}`;
                    });
                });
            });
        }

        if (distillationForm) {
            distillationForm.addEventListener('submit', async (e) => {
                e.preventDefault();
                const topics = document.getElementById('distil-topics').value;
                const debugMode = document.getElementById('distil-debug-mode').checked;

                // Collect anchors
                const anchors = [];
                anchorsContainer.querySelectorAll('.anchor-item').forEach(item => {
                    const question = item.querySelector('.distil-anchor').value;
                    const budget = parseInt(item.querySelector('.distil-budget').value);
                    if (question) {
                        anchors.push({ question, budget });
                    }
                });

                if (anchors.length === 0) {
                    alert("Please provide at least one anchor question.");
                    return;
                }

                // Read global provider settings
                const provider = document.getElementById('llm-provider').value;
                const geminiKey = document.getElementById('gemini-api-key').value.trim();
                const grokKey = document.getElementById('grok-api-key').value.trim();
                const openrouterKey = document.getElementById('openrouter-api-key').value.trim();
                const openrouterMdl = document.getElementById('openrouter-model').value.trim();
                const llamacppServerUrl = document.getElementById('llamacpp-url').value.trim();

                let api_key = '';
                if (provider === 'gemini') api_key = geminiKey;
                if (provider === 'grok') api_key = grokKey;
                if (provider === 'openrouter') api_key = openrouterKey;

                const startBtn = document.getElementById('start-distillation-btn');
                const stopBtn = document.getElementById('stop-distillation-btn');
                const downloadBtn = document.getElementById('download-distillation-btn');
                const tokenBar = document.getElementById('distil-token-bar');
                const distilConsole = document.getElementById('distil-console');

                startBtn.disabled = true;
                startBtn.textContent = "Running...";
                stopBtn.style.display = '';
                downloadBtn.style.display = 'none';
                tokenBar.style.display = '';
                distilConsole.innerHTML = `<div style="color:cyan;">--- Distillation Started (${anchors.length} anchors, Debug: ${debugMode}, Provider: ${provider}) ---</div>`;

                try {
                    const resp = await fetch('/start_distillation', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            topics,
                            anchors,
                            debug_mode: debugMode,
                            provider: provider,
                            api_key: api_key,
                            openrouter_model: openrouterMdl,
                            llamacpp_url: llamacppServerUrl
                        })
                    });

                    if (!resp.ok) {
                        const errData = await resp.json();
                        throw new Error(errData.message || 'Server error');
                    }

                } catch (e) {
                    console.error(e);
                    alert("Error starting distillation: " + e.message);
                    startBtn.disabled = false;
                    startBtn.textContent = "Start Distillation";
                    stopBtn.style.display = 'none';
                }
            });
        }

        // --- Distillation Helper Functions ---

        function appendDistilConsole(msg, color) {
            const el = document.getElementById('distil-console');
            if (!el) return;
            const line = document.createElement('div');
            line.textContent = msg;
            line.style.color = color || '#0f0';
            el.appendChild(line);
            el.scrollTop = el.scrollHeight;
        }

        function updateDistilMetrics(update) {
            const tokenInfo = document.getElementById('distil-token-info');
            const epochInfo = document.getElementById('distil-epoch-info');
            const qaInfo = document.getElementById('distil-qa-info');
            const progress = document.getElementById('distil-progress');
            if (tokenInfo) tokenInfo.textContent = `${(update.token_count || 0).toLocaleString()} / ${(update.token_budget || 0).toLocaleString()} tokens (in: ${(update.input_tokens || 0).toLocaleString()}, out: ${(update.output_tokens || 0).toLocaleString()})`;
            if (epochInfo) epochInfo.textContent = `Epoch: ${update.epoch || 0}`;
            if (qaInfo) qaInfo.textContent = `QA Pairs: ${update.qa_pairs_count || 0}`;
            if (progress && update.token_budget) {
                const pct = Math.min(100, ((update.token_count || 0) / update.token_budget) * 100);
                progress.style.width = pct + '%';
            }
        }

        function renderAsciiTopology(topology, epoch) {
            const el = document.getElementById('distil-topology');
            if (!el || !topology) return;

            const ARCHETYPES = {
                1: 'Initiator', 2: 'Builder', 3: 'Connector', 4: 'Preserver',
                5: 'Performer', 6: 'Analyst', 7: 'Diplomat', 8: 'Transformer',
                9: 'Explorer', 10: 'Architect', 11: 'Visionary', 12: 'Dreamer'
            };

            let lines = [];
            lines.push(`‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó`);
            lines.push(`‚ïë  QNN Topology ‚Äî Epoch ${String(epoch).padStart(3)}                ‚ïë`);
            lines.push(`‚ïë  Structure: 1√ó2√ó2√ó2√ó2√ó2√ó1                ‚ïë`);
            lines.push(`‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù`);
            lines.push('');

            const maxNameLen = 14;

            topology.forEach((layer, li) => {
                const layerLabel = `Layer ${li}`;
                const layerNodes = layer.map(agent => {
                    const name = ARCHETYPES[agent.archetype_id] || 'Mixed';
                    const diff = agent.difficulty_history && agent.difficulty_history.length > 0
                        ? agent.difficulty_history[agent.difficulty_history.length - 1]
                        : '‚Äî';
                    const diffIcon = diff === 'Hard' ? 'üî¥' : diff === 'Easy' ? 'üü¢' : '‚ö™';
                    const inherited = agent.inherited_from ? '‚ß´' : ' ';
                    const shortName = name.substring(0, maxNameLen).padEnd(maxNameLen);
                    return `‚îÇ${inherited}${diffIcon} ${shortName}‚îÇ`;
                });

                // Center the nodes
                const totalWidth = 46;
                const nodeBlockWidth = layerNodes.join('  ').length;
                const indent = Math.max(0, Math.floor((totalWidth - nodeBlockWidth) / 2));
                const padding = ' '.repeat(indent);

                // Draw borders
                const topBorders = layer.map(agent => {
                    return `‚îå${'‚îÄ'.repeat(maxNameLen + 3)}‚îê`;
                });
                const botBorders = layer.map(agent => {
                    return `‚îî${'‚îÄ'.repeat(maxNameLen + 3)}‚îò`;
                });

                lines.push(`  ${layerLabel}`);
                lines.push(`${padding}${topBorders.join('  ')}`);
                lines.push(`${padding}${layerNodes.join('  ')}`);
                lines.push(`${padding}${botBorders.join('  ')}`);

                // Draw connector lines between layers
                if (li < topology.length - 1) {
                    if (layer.length === 1 && topology[li + 1].length === 2) {
                        lines.push(`${padding}       ‚îå‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îê`);
                    } else if (layer.length === 2 && topology[li + 1].length === 2) {
                        lines.push(`${padding}       ‚îÇ     ‚îÇ`);
                    } else if (layer.length === 2 && topology[li + 1].length === 1) {
                        lines.push(`${padding}       ‚îî‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îò`);
                    } else {
                        lines.push(`${padding}         ‚îÇ`);
                    }
                }
            });

            el.textContent = lines.join('\n');
        }

        async function stopDistillation() {
            try {
                await fetch('/stop_distillation', { method: 'POST' });
                appendDistilConsole('‚èπ Stop requested...', '#ff8800');
                if (window._distilEvtSource) {
                    window._distilEvtSource.close();
                    window._distilEvtSource = null;
                }
                const startBtn = document.getElementById('start-distillation-btn');
                const stopBtn = document.getElementById('stop-distillation-btn');
                const downloadBtn = document.getElementById('download-distillation-btn');
                if (startBtn) { startBtn.disabled = false; startBtn.textContent = 'Start Distillation'; }
                if (stopBtn) stopBtn.style.display = 'none';
                if (downloadBtn) downloadBtn.style.display = '';
            } catch (e) {
                console.error('Failed to stop distillation:', e);
            }
        }

        let importedSessionId = null;
        let importedStateContent = null;

        // Brainstorm mode state - chat history and document context
        let brainstormChatHistory = [];  // Array of {role: 'user'|'assistant', content: string}
        let brainstormDocumentContext = '';  // Combined extracted text from PDFs
        let attachedDocuments = [];  // Array of {filename: string, charCount: number}
        let nodeChatInstance = null;  // NodeChat component instance

        // PDF upload elements
        const pdfFileInput = document.getElementById('pdf-file-input');
        const pdfUploadStatus = document.getElementById('pdf-upload-status');
        const clearPdfsBtn = document.getElementById('clear-pdfs-btn');
        const attachedDocumentsList = document.getElementById('attached-documents-list');
        const documentsList = document.getElementById('documents-list');

        // PDF Upload Handler
        pdfFileInput.addEventListener('change', async (e) => {
            const files = e.target.files;
            if (!files.length) return;

            pdfUploadStatus.textContent = 'Uploading...';
            pdfUploadStatus.style.color = '#888';

            const formData = new FormData();
            for (let i = 0; i < files.length; i++) {
                formData.append('files', files[i]);
            }

            try {
                const response = await fetch('/upload_documents', {
                    method: 'POST',
                    body: formData
                });

                const result = await response.json();

                if (response.ok) {
                    const newDocs = result.documents || [];
                    let addedCount = 0;

                    // Append new unique documents
                    newDocs.forEach(doc => {
                        if (!attachedDocuments.some(existing => existing.filename === doc.filename)) {
                            attachedDocuments.push(doc);
                            addedCount++;
                        }
                    });

                    // Re-build context from all attached documents
                    brainstormDocumentContext = attachedDocuments.map(d => `[Document: ${d.filename}]\n${d.text}`).join('\n\n---\n\n');

                    const totalChars = attachedDocuments.reduce((sum, doc) => sum + doc.char_count, 0);

                    if (addedCount > 0) {
                        pdfUploadStatus.textContent = `‚úì Added ${addedCount} new document(s). Total: ${attachedDocuments.length} (${totalChars} chars)`;
                        pdfUploadStatus.style.color = '#28a745';
                    } else {
                        pdfUploadStatus.textContent = `‚ö† Documents already attached. Total: ${attachedDocuments.length}`;
                        pdfUploadStatus.style.color = '#e0a800';
                    }

                    // Update documents list display
                    documentsList.innerHTML = '';
                    attachedDocuments.forEach(doc => {
                        const badge = document.createElement('span');
                        badge.style.cssText = 'background: #262730; padding: 4px 10px; border-radius: 20px; font-size: 0.8rem; display: flex; align-items: center; gap: 4px;';
                        badge.innerHTML = `üìÑ ${doc.filename} <span style="color: #666;">(${doc.char_count} chars)</span>`;
                        documentsList.appendChild(badge);
                    });

                    attachedDocumentsList.style.display = 'block';
                    clearPdfsBtn.style.display = 'inline-block';

                } else {
                    pdfUploadStatus.textContent = `Error: ${result.message}`;
                    pdfUploadStatus.style.color = '#ff4b4b';
                }
            } catch (error) {
                pdfUploadStatus.textContent = `Error: ${error.message}`;
                pdfUploadStatus.style.color = '#ff4b4b';
            }

            // Clear the input for re-selection
            pdfFileInput.value = '';
        });

        // Clear PDFs button handler
        clearPdfsBtn.addEventListener('click', () => {
            brainstormDocumentContext = '';
            attachedDocuments = [];
            documentsList.innerHTML = '';
            attachedDocumentsList.style.display = 'none';
            clearPdfsBtn.style.display = 'none';
            pdfUploadStatus.textContent = '';
        });

        // Mode switching and API key elements
        const modeTabs = document.querySelectorAll('.mode-tab');
        const algorithmMode = document.getElementById('algorithm-mode');
        const brainstormMode = document.getElementById('brainstorm-mode');
        const geminiApiKeyInput = document.getElementById('gemini-api-key');
        const saveApiKeyBtn = document.getElementById('save-api-key-btn');
        const apiKeyStatus = document.getElementById('api-key-status');
        // NodeChat replaces #brainstorm-chat, #brainstorm-form, and #brainstorm-input
        // Initialize after DOM references are set up (see below)
        const llmProviderSelect = document.getElementById('llm-provider');
        const geminiConfig = document.getElementById('gemini-config');
        const grokConfig = document.getElementById('grok-config');
        const openrouterConfig = document.getElementById('openrouter-config');
        const llamacppConfig = document.getElementById('llamacpp-config');


        // Load settings from localStorage on page load
        const savedProvider = localStorage.getItem('llm_provider') || 'gemini';
        const savedApiKey = localStorage.getItem('gemini_api_key');
        const savedGrokApiKey = localStorage.getItem('grok_api_key');
        const savedOpenrouterApiKey = localStorage.getItem('openrouter_api_key');
        const savedOpenrouterModel = localStorage.getItem('openrouter_model');
        const savedLlamacppUrl = localStorage.getItem('llamacpp_url');
        const savedLlamacppEmbeddingUrl = localStorage.getItem('llamacpp_embedding_url');


        llmProviderSelect.value = savedProvider;
        if (savedApiKey) geminiApiKeyInput.value = savedApiKey;
        if (savedGrokApiKey) document.getElementById('grok-api-key').value = savedGrokApiKey;
        if (localStorage.getItem('grok_openrouter_key')) document.getElementById('grok-openrouter-key').value = localStorage.getItem('grok_openrouter_key');
        if (savedOpenrouterApiKey) document.getElementById('openrouter-api-key').value = savedOpenrouterApiKey;
        if (savedOpenrouterModel) document.getElementById('openrouter-model').value = savedOpenrouterModel;
        if (savedLlamacppUrl) document.getElementById('llamacpp-url').value = savedLlamacppUrl;
        if (savedLlamacppEmbeddingUrl) document.getElementById('llamacpp-embedding-url').value = savedLlamacppEmbeddingUrl;


        // Show/hide config based on provider
        const updateProviderConfig = () => {
            geminiConfig.style.display = 'none';
            grokConfig.style.display = 'none';
            openrouterConfig.style.display = 'none';
            llamacppConfig.style.display = 'none';
            if (llmProviderSelect.value === 'gemini') {
                geminiConfig.style.display = 'flex';
            } else if (llmProviderSelect.value === 'grok') {
                grokConfig.style.display = 'flex';
            } else if (llmProviderSelect.value === 'openrouter') {
                openrouterConfig.style.display = 'flex';
            } else if (llmProviderSelect.value === 'llamacpp') {
                llamacppConfig.style.display = 'flex';
            }
        };
        updateProviderConfig();

        if (savedApiKey) {
            apiKeyStatus.textContent = '‚úì Saved';
        }

        // Handle provider change
        llmProviderSelect.addEventListener('change', updateProviderConfig);

        // Save all settings to localStorage
        saveApiKeyBtn.addEventListener('click', () => {
            const provider = llmProviderSelect.value;
            const apiKey = geminiApiKeyInput.value.trim();
            const grokApiKey = document.getElementById('grok-api-key').value.trim();
            const grokOpenrouterKey = document.getElementById('grok-openrouter-key').value.trim();
            const openrouterApiKey = document.getElementById('openrouter-api-key').value.trim();
            const openrouterModel = document.getElementById('openrouter-model').value.trim();
            const llamacppUrl = document.getElementById('llamacpp-url').value.trim();
            const llamacppEmbeddingUrl = document.getElementById('llamacpp-embedding-url').value.trim();


            localStorage.setItem('llm_provider', provider);
            if (apiKey) localStorage.setItem('gemini_api_key', apiKey);
            if (grokApiKey) localStorage.setItem('grok_api_key', grokApiKey);
            if (grokOpenrouterKey) localStorage.setItem('grok_openrouter_key', grokOpenrouterKey);
            if (openrouterApiKey) localStorage.setItem('openrouter_api_key', openrouterApiKey);
            if (openrouterModel) localStorage.setItem('openrouter_model', openrouterModel);
            if (llamacppUrl) localStorage.setItem('llamacpp_url', llamacppUrl);
            if (llamacppEmbeddingUrl) localStorage.setItem('llamacpp_embedding_url', llamacppEmbeddingUrl);


            apiKeyStatus.textContent = '‚úì Saved';
            setTimeout(() => { apiKeyStatus.textContent = ''; }, 2000);
        });

        // Mode tab switching
        modeTabs.forEach(tab => {
            tab.addEventListener('click', () => {
                modeTabs.forEach(t => t.classList.remove('active'));
                tab.classList.add('active');
                const mode = tab.dataset.mode;
                const bs = document.getElementById('brainstorm-mode');
                const algo = document.getElementById('algorithm-mode');
                const distil = document.getElementById('distillation-mode');

                [bs, algo, distil].forEach(c => {
                    if (c) {
                        c.classList.add('hidden');
                        c.classList.remove('active');
                    }
                });

                if (mode === 'brainstorm') {
                    if (bs) { bs.classList.remove('hidden'); bs.classList.add('active'); }
                } else if (mode === 'algorithm') {
                    if (algo) { algo.classList.remove('hidden'); algo.classList.add('active'); }
                } else if (mode === 'distillation') {
                    if (distil) { distil.classList.remove('hidden'); distil.classList.add('active'); }
                }
            });
        });

        // Initialize NodeChat component in the brainstorm container
        // Ensure container is visible before init if necessary, or just init
        if (document.getElementById('node-chat-container')) {
            nodeChatInstance = NodeChat.init('node-chat-container', {
                title: 'Brainstorm',
                subtitle: 'AI-powered expert panel',
                placeholder: 'What would you like to brainstorm?',
                onSend: async (message, chat) => {
                    const provider = localStorage.getItem('llm_provider') || 'gemini';
                    const apiKey = localStorage.getItem('gemini_api_key');
                    const grokApiKey = localStorage.getItem('grok_api_key');
                    const openrouterApiKey = localStorage.getItem('openrouter_api_key');
                    const openrouterModel = localStorage.getItem('openrouter_model') || 'stepfun/step-3.5-flash:free';
                    const llamacppUrl = localStorage.getItem('llamacpp_url') || 'http://localhost:8080/v1/chat/completions';
                    const llamacppEmbeddingUrl = localStorage.getItem('llamacpp_embedding_url') || 'http://localhost:8080/v1';


                    if (provider === 'gemini' && !apiKey) {
                        alert('Please save your Gemini API key in the settings panel first.');
                        chat.finishStreaming();
                        return;
                    }
                    if (provider === 'grok' && !grokApiKey) {
                        alert('Please save your Grok API key in the settings panel first.');
                        chat.finishStreaming();
                        return;
                    }
                    if (provider === 'openrouter' && !openrouterApiKey) {
                        alert('Please save your OpenRouter API key in the settings panel first.');
                        chat.finishStreaming();
                        return;
                    }

                    // Sync chat history
                    brainstormChatHistory = chat.getChatHistory();

                    logContainer.innerHTML = '';
                    fullLogContent = '';

                    // Hide Graph for Brainstorm
                    graphContainer.parentElement.style.display = 'none';

                    addLogMessage(`<strong>User:</strong> ${message}`, { isHTML: true, color: '#a0a0ff' });

                    // Determine the correct API key for the selected provider
                    let selectedApiKey = apiKey;
                    if (provider === 'grok') selectedApiKey = grokApiKey;
                    if (provider === 'openrouter') selectedApiKey = openrouterApiKey;

                    const params = {
                        prompt: message,
                        provider: provider,
                        api_key: selectedApiKey,
                        grok_openrouter_key: document.getElementById('grok-openrouter-key').value.trim(),

                        openrouter_model: openrouterModel,
                        llamacpp_url: llamacppUrl,
                        llamacpp_embedding_url: llamacppEmbeddingUrl,
                        vector_word_size: 2,
                        prompt_alignment: 1.0,
                        density: 1.0,
                        learning_rate: 0.1,
                        num_epochs: document.getElementById('brainstorm_epochs').value || 2,
                        coder_debug_mode: document.getElementById('brainstorm_debug_mode').checked ? 'true' : 'false'
                    };

                    try {
                        await runGraph({
                            params: params,
                            mode: 'brainstorm',
                            chat_history: brainstormChatHistory,
                            document_context: brainstormDocumentContext
                        }, '/build_and_run_graph', false);
                        // Note: finishStreaming will be called by the FINAL_ANSWER SSE handler
                    } catch (error) {
                        addLogMessage(`Error initiating brainstorming: ${error.message}`, { color: 'red' });
                        chat.removeThinking();
                        chat.finishStreaming();
                    }
                },
                onClear: () => {
                    brainstormChatHistory = [];
                }
            });




            downloadLogButton.addEventListener('click', downloadLog);




        } // End if node-chat-container exists



        if (document.getElementById('diagnostic-node-chat-container')) {
            diagnosticChatInstance = NodeChat.init('diagnostic-node-chat-container', {
                title: 'Diagnostic Chat',
                subtitle: 'RAG Index Explorer',
                placeholder: 'Query the RAG index (e.g. "Find documents about transformer decoding")...',
                onSend: async (message, chat) => {
                    if (!currentSessionId) {
                        alert('Please start a graph run first.');
                        chat.finishStreaming();
                        return;
                    }

                    try {
                        const response = await fetch('/diagnostic_chat', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ session_id: currentSessionId, message: message })
                        });
                        if (!response.ok) {
                            const errorText = await response.text();
                            chat.appendAIMessage(`Error: ${errorText}`);
                            return;
                        }

                        const reader = response.body.getReader();
                        const decoder = new TextDecoder();
                        let aiResponseText = '';
                        const bubble = chat.startAIResponse();

                        while (true) {
                            const { value, done } = await reader.read();
                            if (done) break;
                            const chunk = decoder.decode(value, { stream: true });
                            aiResponseText += chunk;
                            chat.updateAIResponse(bubble, aiResponseText);
                        }
                        chat.finishStreaming(aiResponseText);
                    } catch (error) {
                        chat.appendAIMessage(`Error: ${error.message}`);
                    }
                }
            });
            // Lock until session starts
            diagnosticChatInstance.setUILocked(true);
        }



        function parseJsonFromDataString(inputString) {
            const jsonString = inputString.slice(5, inputString.length);
            try {
                return JSON.parse(jsonString);
            } catch (error) {
                console.error("Failed to parse JSON from event stream:", error, "String was:", jsonString);
                return null;
            }
        }

        async function runGraph(payload, endpointUrl, clearLogs = true) {
            runButton.disabled = true;
            runButton.textContent = 'Processing...';
            downloadLogButton.disabled = true;
            if (clearLogs) {
                logContainer.innerHTML = '';
                fullLogContent = '';
            }
            graphContainer.innerHTML = '<p>ASCII graph will be displayed here after the process starts...</p>';

            codeResultContainer.classList.add('hidden');
            modulesContainer.classList.add('hidden');
            graphArchitectureSection.classList.add('hidden');
            qnnImportContainer.classList.add('hidden');

            if (diagnosticChatInstance) {
                diagnosticChatInstance.clearChat();
                diagnosticChatInstance.setUILocked(true);
            }
            allPerplexityValues = [];
            allLbelsData = [];
            renderPerplexityChart();
            addLogMessage(`Sending request to endpoint: ${endpointUrl}`);

            try {
                const response = await fetch(endpointUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                const result = await response.json();


                if (!response.ok) {
                    addLogMessage(`Error: ${result.message}`, { color: 'red' });
                    if (result.traceback) {
                        const pre = document.createElement('pre');
                        pre.style.color = '#ff8c8c';
                        pre.textContent = result.traceback;
                        logContainer.appendChild(pre);
                    }
                } else if (result.code_solution) {

                    let codeToDisplay = result.code_solution;

                    // Robust regex for varied markdown code block formats
                    const codeMatch = /```(?:\w+\n)?([\s\S]*?)```/.exec(codeToDisplay);
                    if (codeMatch) {
                        codeToDisplay = codeMatch[1].trim();
                    } else if (codeToDisplay.includes('def ')) {
                        // Fallback: if it looks like code but no backticks, keep as is
                        codeToDisplay = codeToDisplay.trim();
                    }

                    try {
                        codeToDisplay = codeToDisplay.replace(/\\n/g, '\n').replace(/\\"/g, '"');
                    } catch (e) { }

                    // Visibility first, then content and highlight
                    codeResultContainer.classList.remove('hidden');
                    codeOutput.textContent = codeToDisplay;
                    Prism.highlightElement(codeOutput);
                    codeReasoning.textContent = result.reasoning;
                    exportQnnButton.classList.remove('hidden');

                    if (result.modules && Array.isArray(result.modules) && result.modules.length > 0) {
                        addLogMessage(`Rendering ${result.modules.length} successfully built modules.`, { color: 'cyan' });
                        modulesOutput.innerHTML = '';
                        result.modules.forEach((module, index) => {
                            const moduleDiv = document.createElement('div');
                            moduleDiv.style.marginBottom = '2rem';
                            const cardHeader = document.createElement('h3');
                            cardHeader.textContent = `Module ${index + 1}: Interface Card`;
                            const cardPre = document.createElement('pre');
                            cardPre.textContent = module.card;
                            cardPre.style.cssText = 'background-color:#1C1E25; padding:1rem; border-radius:var(--border-radius); white-space:pre-wrap;';
                            const codeHeader = document.createElement('h3');
                            codeHeader.textContent = `Module ${index + 1}: Source Code`;
                            const codePre = document.createElement('pre');
                            const codeElem = document.createElement('code');
                            codeElem.className = 'language-python';
                            let codeModule = "";
                            const codeMatch = /```(?:python\n)?([\s\S]*?)```/.exec(module.code);
                            if (codeMatch) {
                                codeModule = codeMatch[1].trim();
                            }

                            codeToDisplay = codeModule.replace(/\\n/g, '\n').replace(/\\"/g, '"');
                            codeElem.textContent = codeToDisplay;
                            codePre.appendChild(codeElem);
                            moduleDiv.append(cardHeader, cardPre, codeHeader, codePre);
                            modulesOutput.appendChild(moduleDiv);
                            Prism.highlightElement(codeElem);
                        });
                        modulesContainer.classList.remove('hidden');

                    }


                } else if (result.message === "Chat is now active.") {
                    addLogMessage(`<strong>‚úÖ ${result.message}</strong>`, { isHTML: true, color: 'lime' });
                    currentSessionId = result.session_id;
                    diagnosticChatContainer.classList.add('hidden');

                    exportQnnButton.classList.remove('hidden');
                } else if (result.message === "Graph started.") {
                    // Brainstorming mode - graph is running, SSE events will stream updates
                    addLogMessage(`<strong>‚úÖ ${result.message}</strong> Processing via SSE stream...`, { isHTML: true, color: 'lime' });
                    currentSessionId = result.session_id;
                } else {
                    addLogMessage(`Error: Unexpected response from server: ${JSON.stringify(result)}`, { color: 'red' });
                    graphArchitectureSection.classList.remove('hidden');
                    qnnImportContainer.classList.remove('hidden');
                }
            } catch (error) {
                addLogMessage(`A client-side error occurred: ${error.message}`, { color: 'red' });
                graphArchitectureSection.classList.remove('hidden');
                qnnImportContainer.classList.remove('hidden');
            } finally {

            }
        }

        graphParamsForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            // Ensure graph is visible
            graphContainer.parentElement.style.display = 'block';

            const formData = new FormData(graphParamsForm);
            const params = {};
            formData.forEach((value, key) => {
                if (key === 'mbti_archetypes') {
                    if (!params[key]) params[key] = [];
                    params[key].push(value);
                } else {
                    params[key] = value;
                }
            });
            if (!formData.has('coder_debug_mode')) params.coder_debug_mode = 'false';
            if (!params.mbti_archetypes || params.mbti_archetypes.length < 2) {
                alert('Please select at least 2 MBTI archetypes.');
                return;
            }

            // Include Global Provider Settings
            const provider = document.getElementById('llm-provider').value;
            const geminiKey = document.getElementById('gemini-api-key').value.trim();
            const grokKey = document.getElementById('grok-api-key').value.trim();
            const grokOpenrouterKey = document.getElementById('grok-openrouter-key').value.trim();
            const openrouterKey = document.getElementById('openrouter-api-key').value.trim();
            const openrouterMdl = document.getElementById('openrouter-model').value.trim();
            const llamacppServerUrl = document.getElementById('llamacpp-url').value.trim();
            const llamacppEmbUrl = document.getElementById('llamacpp-embedding-url').value.trim();


            params.provider = provider;
            if (provider === 'gemini') params.api_key = geminiKey;

            if (provider === 'grok') {
                params.api_key = grokKey;
                params.grok_openrouter_key = grokOpenrouterKey;
            }

            if (provider === 'openrouter') params.api_key = openrouterKey;

            params.openrouter_model = openrouterMdl;
            params.llamacpp_url = llamacppServerUrl;
            params.llamacpp_embedding_url = llamacppEmbUrl;

            runGraph({ params, mode: 'algorithm' }, '/build_and_run_graph');
        });

        qnnFileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) {
                importedStateContent = null;
                return;
            }

            const reader = new FileReader();
            reader.onload = (event) => {
                try {
                    importedStateContent = event.target.result;
                    const parsedState = JSON.parse(importedStateContent);

                    loadedFilename.textContent = file.name;

                    const uploadFormData = new FormData();
                    uploadFormData.append('file', file);
                    fetch('/import_qnn', { method: 'POST', body: uploadFormData })
                        .then(res => res.json())
                        .then(result => {
                            if (result.session_id) {
                                importedSessionId = result.session_id;
                                addLogMessage(`QNN '${file.name}' staged for 'Continue Training'. Session: ${importedSessionId}`, { color: 'cyan' });
                            }
                        });

                    if (parsedState.params) {
                        Object.keys(parsedState.params).forEach(key => {
                            const input = graphParamsForm.querySelector(`[name="${key}"]`);
                            if (input && input.type === 'checkbox') {
                                input.checked = parsedState.params[key] === 'true';
                            } else if (input) {
                                input.value = parsedState.params[key];
                            }
                        });
                        if (parsedState.params.mbti_archetypes) {
                            document.querySelectorAll('input[name="mbti_archetypes"]').forEach(cb => {
                                cb.checked = parsedState.params.mbti_archetypes.includes(cb.value);
                            });
                        }
                    }

                    importedQnnInfo.classList.remove('hidden');
                    graphArchitectureSection.classList.add('hidden');

                } catch (error) {
                    alert(`Error parsing QNN file: ${error.message}`);
                    importedStateContent = null;
                }
            };
            reader.readAsText(file);
        });

        const startContinueTrainingRun = () => {
            if (!importedSessionId) {
                alert("No imported session staged for training. Please re-select the file.");
                return;
            }
            const formData = new FormData(graphParamsForm);
            const params = {};
            formData.forEach((value, key) => {
                if (key === 'mbti_archetypes') {
                    if (!params[key]) params[key] = [];
                    params[key].push(value);
                } else {
                    params[key] = value;
                }
            });
            runGraph({ params: params, session_id_to_load: importedSessionId }, '/build_and_run_graph');
        };

        const startInferenceOnlyRun = () => {
            if (!importedStateContent) {
                alert("No QNN file content loaded. Please select a file.");
                return;
            }

            const newPrompt = prompt("Please enter the prompt for the inference-only run:", document.getElementById('prompt').value);

            if (!newPrompt || !newPrompt.trim()) {
                alert("A prompt is required to run inference. Operation cancelled.");
                return;
            }

            const payload = {
                imported_state: JSON.parse(importedStateContent),
                prompt: newPrompt
            };
            runGraph(payload, '/run_inference_from_state');
        };



        inferenceContinueTrainingBtn.addEventListener('click', startContinueTrainingRun);
        inferenceOnlyBtn.addEventListener('click', startInferenceOnlyRun);

        exportQnnButton.addEventListener('click', () => {
            if (currentSessionId) {
                window.location.href = `/export_qnn/${currentSessionId}`;
            } else {
                alert("No active session to export.");

            }

        }

        );

        const eventSource = new EventSource('/stream_log');

        eventSource.onmessage = function (event) {
            const rawMessage = event.data;

            if ((rawMessage.includes('"type":') || rawMessage.startsWith('{')) && (rawMessage.includes('distillation_update') || rawMessage.includes('distillation_complete'))) {
                try {
                    const jsonStr = rawMessage.substring(rawMessage.indexOf('{')).trim();
                    const data = JSON.parse(jsonStr);
                    if (data.type === 'distillation_update') {
                        renderAsciiTopology(data.topology, data.epoch);
                        updateDistilMetrics(data);
                        if (data.perplexity !== undefined && typeof updatePerplexityChart === 'function') {
                            updatePerplexityChart(data.epoch, data.perplexity);
                        }
                        const anchorInfo = data.anchor_index !== undefined ? `[Anchor ${data.anchor_index + 1}/${data.anchor_count}] ` : '';
                        appendDistilConsole(`${anchorInfo}[Epoch ${data.epoch}] Tokens: ${(data.token_count || 0).toLocaleString()} / ${(data.token_budget || 0).toLocaleString()} | QA: ${data.qa_pairs_count || 0}`, '#0ff');
                    }
                    if (data.type === 'distillation_complete') {
                        appendDistilConsole(`‚úì COMPLETE ‚Äî Total QA Pairs: ${data.total_qa_pairs_count}`, '#0f0');
                        // Reset distillation buttons
                        const distilStartBtn = document.getElementById('start-distillation-btn');
                        const distilStopBtn = document.getElementById('stop-distillation-btn');
                        const distilDownloadBtn = document.getElementById('download-distillation-btn');
                        if (distilStartBtn) {
                            distilStartBtn.disabled = false;
                            distilStartBtn.textContent = "Start Distillation";
                        }
                        if (distilStopBtn) distilStopBtn.style.display = 'none';
                        if (distilDownloadBtn) distilDownloadBtn.style.display = '';
                    }
                } catch (e) {
                    console.error("Error parsing distillation update", e);
                }

            } else if (rawMessage.includes('TOKEN_USAGE:')) {
                try {
                    const token = 'TOKEN_USAGE:';
                    let parts = rawMessage.substring(rawMessage.indexOf(token) + token.length).trim();
                    if (parts.startsWith('"') && parts.endsWith('"') && parts.includes('\\"')) {
                        try { parts = JSON.parse(parts); } catch (e) { }
                    }
                    const usage = JSON.parse(parts);
                    document.getElementById('tokens-total').innerText = usage.total;
                    document.getElementById('tokens-prompt').innerText = usage.prompt;
                    document.getElementById('tokens-completion').innerText = usage.completion;
                } catch (e) { console.error("Token parsing error", e); }
                return;

            } else if (rawMessage.includes('FINAL_ANSWER:')) {
                console.log("Received FINAL_ANSWER event:", rawMessage);
                try {
                    // Extract payload regardless of prefix
                    const token = 'FINAL_ANSWER:';
                    let jsonStr = rawMessage.substring(rawMessage.indexOf(token) + token.length).trim();

                    let answer = JSON.parse(jsonStr);

                    // Handle double-encoding (common with MockLLM -> Backend -> Frontend flow)
                    if (typeof answer === 'string') {
                        try {
                            const parsedSecond = JSON.parse(answer);
                            answer = parsedSecond;
                        } catch (e) {
                            // It was just a string, keep as is
                        }
                    }

                    console.log("Parsed answer:", answer);

                    // Route FINAL_ANSWER into NodeChat or Code Result
                    const isAlgorithmResult = answer.mode === 'algorithm' ||
                        (answer.proposed_solution && answer.reasoning && answer.skills_used && answer.skills_used.includes('code_synthesis'));

                    if (isAlgorithmResult) {
                        console.log("Routing to Algorithm Code Result");
                        // Algorithm / Code Result
                        let codeToDisplay = answer.proposed_solution || "";

                        // Robust regex for varied markdown code block formats
                        const codeMatch = /```(?:\w+\n)?([\s\S]*?)```/.exec(codeToDisplay);
                        if (codeMatch) {
                            codeToDisplay = codeMatch[1].trim();
                        } else if (codeToDisplay.includes('def ')) {
                            // Fallback: if it looks like code but no backticks, keep as is
                            codeToDisplay = codeToDisplay.trim();
                        }

                        try {
                            codeToDisplay = codeToDisplay.replace(/\\n/g, '\n').replace(/\\"/g, '"');
                        } catch (e) { }

                        // Visibility first: remove 'hidden' AND ensure parent container is 'active'
                        algorithmMode.classList.remove('hidden');
                        algorithmMode.classList.add('active');
                        codeResultContainer.classList.remove('hidden');

                        codeOutput.textContent = codeToDisplay;
                        Prism.highlightElement(codeOutput);
                        codeReasoning.textContent = answer.reasoning || "Synthesis complete.";
                        exportQnnButton.classList.remove('hidden');

                        addLogMessage(`<strong>‚úÖ Graph results visualized below.</strong>`, { isHTML: true, color: 'lime' });
                    } else if (answer.mode === 'brainstorm' || nodeChatInstance) {
                        // Brainstorm Reflection
                        let displayText = '';
                        if (typeof answer === 'object' && answer !== null) {
                            if (answer.proposed_solution) displayText = answer.proposed_solution;
                            else displayText = JSON.stringify(answer, null, 2);
                        } else {
                            displayText = String(answer);
                        }

                        // Prefix with synthesis header
                        displayText = 'üß† **Synthesis**\n\n' + displayText;

                        if (nodeChatInstance) {
                            nodeChatInstance.appendAIMessage(displayText);
                            // Sync chat history back
                            brainstormChatHistory = nodeChatInstance.getChatHistory();
                        } else {
                            addLogMessage(displayText, { isHTML: true });
                        }
                    }

                } catch (e) {
                    console.error("Failed to parse FINAL_ANSWER", e);
                    addLogMessage(`Error parsing final answer: ${e.message}`, { color: 'red' });
                }
                addLogMessage(rawMessage);

            } else if (rawMessage.includes('__start__')) {

                graphContainer.textContent = rawMessage.replace('__start__', '');
                addLogMessage(">>> ASCII Graph Rendered <<<", { color: 'cyan' });
            } else if (rawMessage.includes('__session_id__')) {
                session_id = rawMessage.replace('__session_id__', '');
                currentSessionId = session_id.replace('data: ', '').trim();

                if (diagnosticChatInstance) {
                    diagnosticChatInstance.setUILocked(false);
                    diagnosticChatInstance.setEyeState('animate');
                    setTimeout(() => diagnosticChatInstance.setEyeState(null), 2000);
                }

                addLogMessage(`>>> Session ID: ${currentSessionId}`, { color: 'cyan' });
                addLogMessage(`<strong>‚úÖ Diagnostic chat is now active.</strong>`, { isHTML: true, color: 'lime' });
                return;
            } else if (rawMessage.startsWith('DISTILLATION_LOG:')) {
                const msg = rawMessage.replace('DISTILLATION_LOG:', '').trim();
                if (typeof appendDistilConsole === 'function') {
                    appendDistilConsole(msg, '#aaffaa');
                }

            } else {
                if (rawMessage.trim().startsWith(':') || rawMessage.includes('keepalive')) return;
                if (rawMessage.startsWith('DISTILLATION_LOG:')) return;
                addLogMessage(rawMessage);
            }

        };

        eventSource.onerror = function (err) {
            console.error("EventSource failed:", err);
            addLogMessage("Error: Connection to server log stream lost. Please refresh and try again.", { color: 'red' });
            eventSource.close();
        };

        // Legacy diagnostic listeners removed
    </script>
    <script src="js/prism-core.min.js"></script>
    <script src="js/prism-autoloader.min.js"></script>
    <script src="js/prism-toolbar.min.js"></script>
    <script src="js/prism-copy-to-clipboard.min.js"></script>
</body>

</html>